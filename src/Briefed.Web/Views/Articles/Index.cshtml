@model IEnumerable<Briefed.Core.Entities.Article>
@{
    ViewData["Title"] = "Articles";
    var filter = ViewData["Filter"]?.ToString() ?? "all";
}

<div class="d-flex justify-content-between align-items-center mb-4">
    <h2>üìñ Articles</h2>
    <div>
        <form asp-action="RefreshFeeds" method="post" class="d-inline">
            @Html.AntiForgeryToken()
            <button type="submit" class="btn btn-outline-primary">üîÑ Refresh Feeds</button>
        </form>
    </div>
</div>

<ul class="nav nav-tabs mb-4">
    <li class="nav-item">
        <a class="nav-link @(filter == "all" ? "active" : "")" asp-action="Index" asp-route-filter="all">All</a>
    </li>
    <li class="nav-item">
        <a class="nav-link @(filter == "unread" ? "active" : "")" asp-action="Index" asp-route-filter="unread">Unread</a>
    </li>
    <li class="nav-item">
        <a class="nav-link @(filter == "read" ? "active" : "")" asp-action="Index" asp-route-filter="read">Read</a>
    </li>
</ul>

@if (!Model.Any())
{
    <div class="alert alert-info">
        <h5>No articles found</h5>
        <p>
            @if (filter == "unread")
            {
                <text>You're all caught up! No unread articles.</text>
            }
            else
            {
                <text>No articles available. Try adding some RSS feeds or refreshing your feeds.</text>
            }
        </p>
        <a asp-controller="Feeds" asp-action="Index" class="btn btn-primary">Manage Feeds</a>
    </div>
}
else
{
    var favoriteFeedIds = ViewBag.FavoriteFeedIds as List<int> ?? new List<int>();
    var feedGroups = Model.GroupBy(a => a.FeedId)
        .OrderByDescending(g => favoriteFeedIds.Contains(g.Key))
        .ThenBy(g => g.First().Feed.Title);
    
    @foreach (var feedGroup in feedGroups)
    {
        var feed = feedGroup.First().Feed;
        var feedId = "feed-" + feed.Id;
        var isFavorite = favoriteFeedIds.Contains(feed.Id);
        var unreadCount = ViewBag.UnreadCountsByFeed != null && ViewBag.UnreadCountsByFeed.ContainsKey(feed.Id) 
            ? ViewBag.UnreadCountsByFeed[feed.Id] 
            : 0;
        <div class="mb-3">
            <div class="card">
                <div class="card-header swipeable-feed-header" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#@feedId" aria-expanded="false" data-feed-id="@feed.Id" data-feed-title="@feed.Title" data-unread-count="@unreadCount">
                    <div class="swipe-action-indicator">
                        <span class="swipe-icon">‚úì</span>
                    </div>
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center">
                            <i class="collapse-icon me-2"></i>
                            @if (!string.IsNullOrEmpty(feed.FaviconUrl))
                            {
                                <img src="@feed.FaviconUrl" alt="@feed.Title icon" class="me-2" style="width: 20px; height: 20px;" onerror="this.style.display='none'" />
                            }
                            else
                            {
                                <span class="me-2">üì∞</span>
                            }
                            <h5 class="mb-0">@feed.Title</h5>
                        </div>
                        <div class="d-flex align-items-center gap-2" onclick="event.stopPropagation();">
                            @if (unreadCount > 0)
                            {
                                <span class="badge bg-primary" id="unread-badge-@feed.Id">@unreadCount unread</span>
                            }
                            else
                            {
                                <span class="badge bg-secondary" id="unread-badge-@feed.Id">All read</span>
                            }
                            <button type="button" class="btn btn-sm @(isFavorite ? "btn-warning" : "btn-outline-warning")" 
                                    id="favorite-btn-@feed.Id"
                                    title="@(isFavorite ? "Remove from favorites" : "Add to favorites")" 
                                    onclick="toggleFavorite(@feed.Id, '@feed.Title')">
                                @(isFavorite ? "‚òÖ" : "‚òÜ")
                            </button>
                            <button type="button" class="btn btn-sm btn-info" 
                                    id="resync-btn-@feed.Id"
                                    title="Re-sync article dates" 
                                    onclick="resyncDates(@feed.Id, '@feed.Title')">
                                üîÑ
                            </button>
                            <button type="button" class="btn btn-sm btn-success" 
                                    id="mark-read-btn-@feed.Id"
                                    title="Mark all as read" 
                                    @(unreadCount == 0 ? "disabled" : "")
                                    onclick="markAllAsRead(@feed.Id, '@feed.Title')">
                                ‚úì
                            </button>
                        </div>
                    </div>
                </div>
                <div id="@feedId" class="collapse">
                    <div class="card-body p-0">
                        @{
                            var readArticleIds = ViewBag.ReadArticleIds as HashSet<int> ?? new HashSet<int>();
                        }
                        @foreach (var article in feedGroup.OrderByDescending(a => a.PublishedAt))
                        {
                            var isRead = readArticleIds.Contains(article.Id);
                            var cardClass = isRead ? "border-bottom p-3 read-article" : "border-bottom p-3";
                            <div class="@cardClass">
                                <div class="d-flex justify-content-between align-items-start">
                                    <div class="flex-grow-1">
                                        <h5 class="mb-1">
                                            <a href="@Url.Action("Read", new { id = article.Id })" class="text-decoration-none @(isRead ? "text-muted" : "text-dark")">
                                                @article.Title
                                            </a>
                                            @if (article.Summary != null)
                                            {
                                                <span class="badge bg-success ms-2">‚ú® Summarised</span>
                                            }
                                        </h5>
                                        <p class="card-text text-muted small mb-2">
                                            @article.PublishedAt.ToLocalTime().ToString("MMM dd, yyyy h:mm tt")
                                        </p>
                                        @if (!string.IsNullOrEmpty(article.Description))
                                        {
                                            var excerpt = article.Description.Length > 200 
                                                ? article.Description.Substring(0, 200) + "..." 
                                                : article.Description;
                                            <p class="card-text mb-2">@excerpt</p>
                                        }
                                        <div class="mt-2">
                                            <a href="@Url.Action("Read", new { id = article.Id })" class="btn btn-sm btn-primary">Read</a>
                                            <div class="btn-group" role="group">
                                                <button type="button" class="btn btn-sm btn-outline-success summarise-article-btn" data-article-id="@article.Id" data-summary-type="comprehensive">
                                                    ‚ú® Summarise
                                                </button>
                                                <button type="button" class="btn btn-sm btn-outline-success dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" aria-expanded="false">
                                                    <span class="visually-hidden">Toggle</span>
                                                </button>
                                                <ul class="dropdown-menu dropdown-menu-end">
                                                    <li><a class="dropdown-item article-summary-type" href="#" data-article-id="@article.Id" data-type="comprehensive">üìù Comprehensive</a></li>
                                                    <li><a class="dropdown-item article-summary-type" href="#" data-article-id="@article.Id" data-type="concise">‚ö° Concise</a></li>
                                                </ul>
                                            </div>
                                            <form asp-action="MarkAsRead" asp-route-id="@article.Id" method="post" class="d-inline mark-read-form" data-article-id="@article.Id" data-feed-id="@article.FeedId">
                                                @Html.AntiForgeryToken()
                                                <button type="submit" class="btn btn-sm btn-outline-info">‚úì Mark as Read</button>
                                            </form>
                                            <a href="@article.Url" target="_blank" class="btn btn-sm btn-outline-secondary">Open Original</a>
                                        </div>
                                        <div id="summary-@article.Id" class="mt-3" style="display: none;">
                                            <div class="card bg-light">
                                                <div class="card-body">
                                                    <h6 class="card-subtitle mb-2">ü§ñ AI Summary</h6>
                                                    <p class="card-text summary-content"></p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    @if (!string.IsNullOrEmpty(article.ImageUrl))
                                    {
                                        <img src="@article.ImageUrl" alt="Article thumbnail" class="ms-3" style="width: 100px; height: 100px; object-fit: cover; border-radius: 4px;" onerror="this.style.display='none'" />
                                    }
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    }
}

@section Scripts {
    <script>
        // Swipe to mark as read functionality
        (function() {
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;
            let activeHeader = null;
            let isCollapsePrevented = false;
            
            const minSwipeDistance = 80;
            const maxVerticalDeviation = 50;
            
            document.querySelectorAll('.swipeable-feed-header').forEach(header => {
                header.addEventListener('touchstart', function(e) {
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                    activeHeader = this;
                    isCollapsePrevented = false;
                }, { passive: true });
                
                header.addEventListener('touchmove', function(e) {
                    if (!activeHeader) return;
                    
                    touchEndX = e.changedTouches[0].screenX;
                    touchEndY = e.changedTouches[0].screenY;
                    
                    const deltaX = touchStartX - touchEndX;
                    const deltaY = Math.abs(touchStartY - touchEndY);
                    
                    // Only handle horizontal swipes
                    if (Math.abs(deltaX) > 10 && deltaY < maxVerticalDeviation) {
                        // Prevent collapse toggle during horizontal swipe
                        if (!isCollapsePrevented) {
                            isCollapsePrevented = true;
                        }
                        
                        // Visual feedback for left swipe
                        if (deltaX > 0) {
                            const swipeProgress = Math.min(deltaX / minSwipeDistance, 1);
                            this.style.transform = `translateX(-${deltaX * 0.5}px)`;
                            this.style.transition = 'none';
                            
                            const indicator = this.querySelector('.swipe-action-indicator');
                            indicator.style.opacity = swipeProgress;
                            indicator.style.right = `${-100 + (deltaX * 0.5)}px`;
                        }
                    }
                }, { passive: true });
                
                header.addEventListener('touchend', function(e) {
                    if (!activeHeader) return;
                    
                    touchEndX = e.changedTouches[0].screenX;
                    touchEndY = e.changedTouches[0].screenY;
                    
                    const deltaX = touchStartX - touchEndX;
                    const deltaY = Math.abs(touchStartY - touchEndY);
                    
                    // Reset visual state
                    this.style.transform = '';
                    this.style.transition = 'transform 0.3s ease';
                    
                    const indicator = this.querySelector('.swipe-action-indicator');
                    indicator.style.opacity = '0';
                    indicator.style.right = '-100px';
                    indicator.style.transition = 'opacity 0.3s ease, right 0.3s ease';
                    
                    // Check if it's a valid left swipe
                    if (deltaX > minSwipeDistance && deltaY < maxVerticalDeviation) {
                        const feedId = this.dataset.feedId;
                        const feedTitle = this.dataset.feedTitle;
                        const unreadCount = parseInt(this.dataset.unreadCount);
                        
                        // Only trigger if there are unread articles
                        if (unreadCount > 0) {
                            markAllAsRead(feedId, feedTitle);
                        }
                        
                        // Prevent collapse toggle
                        e.preventDefault();
                        e.stopPropagation();
                    } else if (isCollapsePrevented) {
                        // If we prevented collapse during move but didn't complete swipe,
                        // still prevent the collapse from triggering
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    
                    activeHeader = null;
                    isCollapsePrevented = false;
                    
                    // Reset transition after animation
                    setTimeout(() => {
                        this.style.transition = '';
                    }, 300);
                }, { passive: false });
                
                // Handle click separately to prevent conflicts
                header.addEventListener('click', function(e) {
                    if (isCollapsePrevented) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            });
        })();
        
        // Handle summary type selection for articles
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.article-summary-type').forEach(option => {
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const articleId = this.dataset.articleId;
                    const summaryType = this.dataset.type;
                    const btn = document.querySelector(`.summarise-article-btn[data-article-id="${articleId}"]`);
                    if (btn) {
                        btn.dataset.summaryType = summaryType;
                        console.log(`Summary type set to ${summaryType} for article ${articleId}`);
                    }
                    // Close dropdown after selection
                    const dropdown = bootstrap.Dropdown.getInstance(this.closest('.dropdown-menu').previousElementSibling);
                    if (dropdown) dropdown.hide();
                });
            });
        });
        
        document.querySelectorAll('.summarise-article-btn').forEach(button => {
            button.addEventListener('click', async function() {
                const articleId = this.dataset.articleId;
                const summaryType = this.dataset.summaryType || 'comprehensive';
                const originalText = this.innerHTML;
                const summaryDiv = document.getElementById('summary-' + articleId);
                const summaryContent = summaryDiv.querySelector('.summary-content');
                
                this.disabled = true;
                this.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Generating...';
                
                try {
                    const response = await fetch(`/Articles/Summarise?id=${articleId}&summaryType=${summaryType}`, {
                        method: 'POST',
                        headers: {
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        }
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        summaryContent.textContent = result.summary;
                        summaryDiv.style.display = 'block';
                        this.innerHTML = '‚úì Summarised';
                        this.classList.remove('btn-outline-success');
                        this.classList.add('btn-success');
                    } else {
                        alert('Error: ' + (result.error || 'Failed to generate summary'));
                        this.innerHTML = originalText;
                        this.disabled = false;
                    }
                } catch (error) {
                    alert('Error generating summary: ' + error.message);
                    this.innerHTML = originalText;
                    this.disabled = false;
                }
            });
        });
        
        // Handle mark as read form submission
        document.querySelectorAll('.mark-read-form').forEach(form => {
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const articleId = this.dataset.articleId;
                const feedId = this.dataset.feedId;
                const button = this.querySelector('button');
                const articleCard = this.closest('.card');
                
                button.disabled = true;
                button.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Marking...';
                
                try {
                    const formData = new FormData(this);
                    const response = await fetch(this.action, {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        button.innerHTML = '‚úì Read';
                        button.classList.remove('btn-outline-info');
                        button.classList.add('btn-info');
                        
                        // Update the unread count badge
                        const badge = document.getElementById(`unread-badge-${feedId}`);
                        if (badge) {
                            const currentText = badge.textContent;
                            if (currentText.includes('unread')) {
                                const count = parseInt(currentText.match(/\d+/)?.[0] || '0');
                                if (count > 1) {
                                    badge.textContent = `${count - 1} unread`;
                                } else {
                                    badge.className = 'badge bg-secondary';
                                    badge.textContent = 'All read';
                                }
                            }
                        }
                        
                        // If on "unread" filter, fade out the article
                        if (window.location.search.includes('filter=unread')) {
                            articleCard.style.opacity = '0.5';
                            setTimeout(() => {
                                articleCard.remove();
                            }, 1000);
                        }
                    } else {
                        alert('Error: ' + (result.error || 'Failed to mark as read'));
                        button.innerHTML = '‚úì Mark as Read';
                        button.disabled = false;
                    }
                } catch (error) {
                    alert('Error marking as read: ' + error.message);
                    button.innerHTML = '‚úì Mark as Read';
                    button.disabled = false;
                }
            });
        });
        
        // Rotate chevron icon on collapse
        document.querySelectorAll('[data-bs-toggle="collapse"]').forEach(element => {
            element.addEventListener('click', function() {
                const icon = this.querySelector('.collapse-icon');
                if (icon) {
                    icon.classList.toggle('bi-chevron-right');
                    icon.classList.toggle('bi-chevron-down');
                }
            });
        });

        // Mark all articles as read via AJAX
        async function markAllAsRead(feedId, feedTitle) {
            const button = document.getElementById(`mark-read-btn-${feedId}`);
            const badge = document.getElementById(`unread-badge-${feedId}`);
            
            // Disable button during request
            button.disabled = true;
            button.innerHTML = '‚è≥';

            try {
                const response = await fetch(`/Feeds/MarkAllAsReadJson/${feedId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]')?.value || ''
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Update badge
                    badge.className = 'badge bg-secondary';
                    badge.textContent = 'All read';
                    
                    // Keep button disabled
                    button.innerHTML = '‚úì';
                    
                    // Show success message (optional)
                    console.log(result.message);
                } else {
                    alert(result.message || 'Failed to mark articles as read');
                    button.disabled = false;
                    button.innerHTML = '‚úì';
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to mark articles as read');
                button.disabled = false;
                button.innerHTML = '‚úì';
            }
        }
        
        // Toggle favorite status via AJAX
        async function toggleFavorite(feedId, feedTitle) {
            const button = document.getElementById(`favorite-btn-${feedId}`);
            const originalIcon = button.textContent;
            
            // Disable button during request
            button.disabled = true;

            try {
                const response = await fetch(`/Feeds/ToggleFavorite/${feedId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]')?.value || ''
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Update button appearance
                    if (result.isFavorite) {
                        button.textContent = '‚òÖ';
                        button.className = 'btn btn-sm btn-warning';
                        button.title = 'Remove from favorites';
                    } else {
                        button.textContent = '‚òÜ';
                        button.className = 'btn btn-sm btn-outline-warning';
                        button.title = 'Add to favorites';
                    }
                    button.disabled = false;
                    
                    // Reload page to resort feeds
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                } else {
                    alert(result.message || 'Failed to toggle favorite');
                    button.disabled = false;
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to toggle favorite');
                button.textContent = originalIcon;
                button.disabled = false;
            }
        }
        
        // Re-sync article dates via AJAX
        async function resyncDates(feedId, feedTitle) {
            if (!confirm(`Re-sync article dates for ${feedTitle}? This will update the publication dates for all articles in this feed.`)) {
                return;
            }

            const button = document.getElementById(`resync-btn-${feedId}`);
            const originalIcon = button.textContent;
            
            // Disable button during request
            button.disabled = true;
            button.textContent = '‚è≥';

            try {
                const response = await fetch(`/Feeds/ResyncDates/${feedId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]')?.value || ''
                    }
                });

                const result = await response.json();

                if (result.success) {
                    button.textContent = '‚úì';
                    
                    // Reload page to show updated dates
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                } else {
                    alert(result.message || 'Failed to re-sync dates');
                    button.textContent = originalIcon;
                    button.disabled = false;
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to re-sync dates');
                button.textContent = originalIcon;
                button.disabled = false;
            }
        }
    </script>
    <style>
        .collapse-icon {
            transition: transform 0.3s ease;
            display: inline-block;
            font-style: normal;
        }
        .collapse-icon:before {
            content: '‚ñ∂';
            font-size: 0.8em;
        }
        [aria-expanded="true"] .collapse-icon:before {
            content: '‚ñº';
        }
        .card-header:hover {
            background-color: var(--bg-secondary);
        }
        .read-article {
            background: linear-gradient(to right, rgba(200, 200, 200, 0.1), rgba(200, 200, 200, 0.05));
        }
        [data-theme="dark"] .read-article {
            background: linear-gradient(to right, rgba(100, 100, 100, 0.15), rgba(100, 100, 100, 0.05));
        }
        .read-article .card-body {
            color: var(--text-secondary);
        }
        
        /* Ensure dropdown menus in read articles are fully opaque */
        .read-article .dropdown-menu {
            opacity: 1 !important;
        }
        
        /* Swipe to mark as read styles */
        .swipeable-feed-header {
            position: relative;
            overflow: visible;
            touch-action: pan-y;
        }
        
        .swipe-action-indicator {
            position: absolute;
            right: -100px;
            top: 0;
            height: 100%;
            width: 100px;
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 0;
            border-radius: 0 4px 4px 0;
        }
        
        .swipe-action-indicator .swipe-icon {
            font-size: 2.5em;
        }
        
        .swipeable-feed-header > .d-flex {
            position: relative;
            z-index: 1;
            background: var(--bs-card-cap-bg, #f8f9fa);
        }
        
        [data-theme="dark"] .swipeable-feed-header > .d-flex {
            background: var(--bs-dark, #212529);
        }
        
        /* Fix dropdown menu visibility and styling */
        .dropdown-menu {
            z-index: 1050 !important;
            background-color: white;
            border: 1px solid rgba(0,0,0,.15);
            box-shadow: 0 .5rem 1rem rgba(0,0,0,.175);
        }
        
        [data-theme="dark"] .dropdown-menu {
            background-color: #2b3035;
            border-color: rgba(255,255,255,.15);
        }
        
        .dropdown-item {
            color: #212529;
            cursor: pointer;
        }
        
        [data-theme="dark"] .dropdown-item {
            color: #e9ecef;
        }
        
        .dropdown-item:hover {
            background-color: #f8f9fa;
        }
        
        [data-theme="dark"] .dropdown-item:hover {
            background-color: #495057;
        }
    </style>
}
